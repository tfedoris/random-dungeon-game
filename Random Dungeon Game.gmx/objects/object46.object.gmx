<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.totalLockedDoors = 0;
global.total_keys_world = 0;
global.total_boss_keys = 0;
global.puzzles_used = ds_list_create();
global.enemy_rooms_used = ds_list_create();
global.num_enemy_rooms = 0;
global.current_puzzle = -4;
global.viewRoom = noone;

global.wait_frames = 30;

start_module = instance_create(0, 0, obj_room);
global.viewRoom = start_module;
start_module.origin_x = room_width div 2;
start_module.origin_y = room_height div 2;
start_module.x = start_module.origin_x;
start_module.y = start_module.origin_y;

instance_create(start_module.origin_x + (256 div 2),
                start_module.origin_y + (176 div 2),
                obj_player);
                
currentModule = noone;
finished_modules = ds_list_create();
tile_size = 16;
Iterations = 2;

randomize();

usedCoordinates = ds_list_create();
var pendingModules = ds_list_create();
var pendingModuleExits = noone;
var collision = false;

ds_list_add(pendingModules, start_module);
ds_list_add(finished_modules, start_module);

//Start generating dungeon
for (var g = 1; g &lt;= Iterations; g++)
{
    var pendingModules_size = ds_list_size(pendingModules);
    var newPendingModules = ds_list_create();
    //Evaluate each pending module
    for (var m = 0; m &lt; pendingModules_size; m++)
    {
        currentModule = ds_list_find_value(pendingModules, m);
        //Get exits
        pendingModuleExits = get_pending_exits(currentModule);
        
        //Determine number of rooms to spawn from current room
        var pendingModuleExits_size = ds_list_size(pendingModuleExits);
        var numExits = irandom_range(1, pendingModuleExits_size + 1);
        if (numExits &gt;= pendingModuleExits_size + 1) 
        {
            numExits = pendingModuleExits_size;
        }
        var numExitsLeft = numExits;
        var currentIndex = 0;
        var usedIndexes = ds_list_create();
        var indexUsed = false;
        
        //Start spawning rooms
        while(numExitsLeft &gt; 0)
        {
            var tries = 0;
            
            do
            {
                randomize();
                indexUsed = false;
                currentIndex = irandom_range(0, pendingModuleExits_size);
                
                if (currentIndex &gt;= pendingModuleExits_size)
                {
                    currentIndex = pendingModuleExits_size - 1;
                }
                
                var usedIndexes_size = ds_list_size(usedIndexes);
                
                if (usedIndexes_size &gt; 0)
                {
                    for (var u = 0; u &lt; usedIndexes_size; u++)
                    {
                        if (currentIndex == ds_list_find_value(usedIndexes, u))
                        {
                            indexUsed = true;
                            break;
                        }
                    }
                }
            }
            until (indexUsed == false);
            
            ds_list_add(usedIndexes, currentIndex);
            
            var exitToMatch = ds_list_find_value(pendingModuleExits, currentIndex);
            var new_origin_x = 0;
            var new_origin_y = 0;
            
            switch(exitToMatch)
            {
                case 'N':
                    new_origin_x = currentModule.origin_x;
                    new_origin_y = currentModule.origin_y - 176;
                    room_direction = 'N';
                    break;
                case 'S':
                    new_origin_x = currentModule.origin_x;
                    new_origin_y = currentModule.origin_y + 176;
                    room_direction = 'S';
                    break;
                case 'E':
                    new_origin_x = currentModule.origin_x + 256;
                    new_origin_y = currentModule.origin_y;
                    room_direction = 'E';
                    break;
                case 'W':
                    new_origin_x = currentModule.origin_x - 256;
                    new_origin_y = currentModule.origin_y;
                    room_direction = 'W';
                    break;
            }
            
            //Check for collision
            var coordinateStr = string(new_origin_x) + ", " + string(new_origin_y);
            
            
            //Don't create room if collision occurs
            if (check_room_collision(coordinateStr))
            {
                collision = true;
                numExitsLeft--;
            }
            
            //Otherwise, finalize room creation
            else
            {
                collision = false;
                numExitsLeft--;
                
                ds_list_add(usedCoordinates, coordinateStr);
                
                newModule = instance_create(new_origin_x, new_origin_y, obj_room);
                newModule.origin_x = new_origin_x;
                newModule.origin_y = new_origin_y;
                
                switch(exitToMatch)
                {
                    case 'N':
                        currentModule.north_room = newModule;
                        newModule.south_room = currentModule;
                        break;
                    case 'S':
                        currentModule.south_room = newModule;
                        newModule.north_room = currentModule;
                        break;
                    case 'E':
                        currentModule.east_room = newModule;
                        newModule.west_room = currentModule;
                        break;
                    case 'W':
                        currentModule.west_room = newModule;
                        newModule.east_room = currentModule;
                        break;
                }
                newModule.generation = g;
                ds_list_add(finished_modules, newModule);
                ds_list_add(newPendingModules, newModule);
            }
                
        }
    }
    pendingModules = newPendingModules;
}

generate_locked_doors();

if (global.totalLockedDoors == 0 || global.totalLockedDoors &gt; 15)
{
    with(obj_player) instance_destroy();
    room_restart();
}

generate_keys();
generate_boss_keys();

//Determine which rooms will have enemies
generate_enemy_rooms();


//Start adding boss entrance and final boss rooms
finished_modules_size = ds_list_size(finished_modules);
hasValidExit = false;
offset = 1;
finalPendingExits = noone;
exit_tries = 0
used_i = ds_list_create();

do
{
    //check for valid module to attach boss rooms to
    hasValidExit = false;
    while (!hasValidExit)
    {
        //If no modules were valid, that means that it's not possible to add boss rooms
        //so we must restart the room
        if (finished_modules_size - offset &lt;= 0)
        {
            with(obj_player) instance_destroy();
            room_restart();
        }
        finalPendingExits = get_pending_exits(finished_modules[| finished_modules_size - offset]);
        finalPendingExits_size = ds_list_size(finalPendingExits);
        if (finalPendingExits_size &gt; 0)
        {
            hasValidExit = true;
        }   
        else
        {
            offset++;
            hasValidExit = false;
        }
    }
    
    do
    {
        randomize();
        validModule = finished_modules[| (finished_modules_size - offset)];
        exitI = irandom(finalPendingExits_size - 1);
        bossExit = finalPendingExits[| exitI];
        used_i_size = ds_list_size(used_i);
        alreadyUsed = false;
        
        for (var u = 0; u &lt; used_i_size; u++)
        {
            if (exitI == used_i[| u])
            {
                alreadyUsed = true;
            }
        }
    }
    until (!alreadyUsed);
    
    ds_list_add(used_i, exitI);
    
    switch(bossExit)
    {
        case 'N':
            new_origin_x = validModule.origin_x;
            new_origin_y = validModule.origin_y - 176;
            break;
        case 'S':
            new_origin_x = validModule.origin_x;
            new_origin_y = validModule.origin_y + 176;
            break;
        case 'E':
            new_origin_x = validModule.origin_x + 256;
            new_origin_y = validModule.origin_y;
            break;
        case 'W':
            new_origin_x = validModule.origin_x - 256;
            new_origin_y = validModule.origin_y;
            break;
    }

    coordinateStr = string(new_origin_x) + ", " + string(new_origin_y);
    
    if (check_room_collision(coordinateStr))
    {
        tries++;
        if (exit_tries &gt;= finalPendingExits_size) offset++;
        tries = 0;
        ds_list_destroy(used_i);
        used_i = ds_list_create();
    }
}
until (!check_room_collision(coordinateStr));

ds_list_add(usedCoordinates, coordinateStr);

//If a valid room was found, create it
boss_entrance = instance_create(new_origin_x, new_origin_y, obj_room);
boss_entrance.origin_x = new_origin_x;
boss_entrance.origin_y = new_origin_y;
boss_entrance.is_boss_room = true;

switch(bossExit)
{
    case 'N':
        validModule.north_room = boss_entrance;
        boss_entrance.south_room = validModule;
        break;
    case 'S':
        validModule.south_room = boss_entrance;
        boss_entrance.north_room = validModule;
        break;
    case 'E':
        validModule.east_room = boss_entrance;
        boss_entrance.west_room = validModule;
        break;
    case 'W':
        validModule.west_room = boss_entrance;
        boss_entrance.east_room = validModule;
        break;
}

collision = true;
north_collision = false;
south_collision = false;
west_collision = false;
east_collision = false;


//Create the final boss room, prioritizing it spawning north or south of the boss entrance
//for asthetic reasons. If it can't be spawned, or if the boss entrance somehow does not 
//exist, then the room must be restarted.
while (collision)
{
    if (instance_exists(boss_entrance))
    {
        if (!instance_exists(boss_entrance.north_room) &amp;&amp; !north_collision)
        {
            new_origin_x = boss_entrance.origin_x;
            new_origin_y = boss_entrance.origin_y - 176;
            coordinateStr = string(new_origin_x) + ", " + string(new_origin_y);
            
            if (!check_room_collision(coordinateStr))
            {
                collision = false;
                boss_module = instance_create(new_origin_x, new_origin_y, obj_boss_room);
                boss_module.origin_x = new_origin_x;
                boss_module.origin_y = new_origin_y;
                boss_module.south_room = boss_entrance;
                boss_entrance.north_room = boss_module;
                boss_entrance.north_locked = true;
                boss_entrance.north_boss = true;
            }
            else
            { 
                collision = true;
                north_collision = true;
            }
        }
        else
        {
            if (!instance_exists(boss_entrance.south_room) &amp;&amp; !south_collision)
            {
                new_origin_x = boss_entrance.origin_x;
                new_origin_y = boss_entrance.origin_y + 176;
                coordinateStr = string(new_origin_x) + ", " + string(new_origin_y);
                
                if (!check_room_collision(coordinateStr))
                {
                    collision = false;
                    boss_module = instance_create(new_origin_x, new_origin_y, obj_boss_room);
                    boss_module.origin_x = new_origin_x;
                    boss_module.origin_y = new_origin_y;
                    boss_module.north_room = boss_entrance;
                    boss_entrance.south_room = boss_module;
                    boss_entrance.south_locked = true;
                    boss_entrance.south_boss = true;
                }
                else
                { 
                    collision = true;
                    south_collision = true;
                }
            }
            else
            {
                if (!instance_exists(boss_entrance.west_room) &amp;&amp; !west_collision)
                {
                    new_origin_x = boss_entrance.origin_x - 256;
                    new_origin_y = boss_entrance.origin_y;
                    coordinateStr = string(new_origin_x) + ", " + string(new_origin_y);
                    
                    if (!check_room_collision(coordinateStr))
                    {
                        collision = false;
                        boss_module = instance_create(new_origin_x, new_origin_y, obj_boss_room);
                        boss_module.origin_x = new_origin_x;
                        boss_module.origin_y = new_origin_y;
                        boss_module.east_room = boss_entrance;
                        boss_entrance.west_room = boss_module;
                        boss_entrance.west_locked = true;
                        boss_entrance.west_boss = true;
                    }
                    else
                    { 
                        collision = true;
                        west_collision = true;
                    }
                }
                else
                {
                    if (!instance_exists(boss_entrance.east_room))
                    {
                        new_origin_x = boss_entrance.origin_x + 256;
                        new_origin_y = boss_entrance.origin_y;
                        coordinateStr = string(new_origin_x) + ", " + string(new_origin_y);
                        
                        if (!check_room_collision(coordinateStr))
                        {
                            boss_module = instance_create(new_origin_x, new_origin_y, obj_boss_room);
                            boss_module.origin_x = new_origin_x;
                            boss_module.origin_y = new_origin_y;
                            boss_module.west_room = boss_entrance;
                            boss_entrance.east_room = boss_module;
                            boss_entrance.east_locked = true;
                            boss_entrance.east_boss = true;
                        }
                        else
                        {
                            with(obj_player) instance_destroy();
                            room_restart();
                        }
                    }
                    else
                    {
                        with(obj_player) instance_destroy();
                        room_restart();
                    }
                }   
            }
        }
    }
    else
    {
        with(obj_player) instance_destroy();
        room_restart();
    }
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!audio_is_playing(mus_dungeon01) &amp;&amp; instance_exists(obj_player)) audio_play_sound(mus_dungeon01, 5, true);

if (audio_is_playing(mus_jingle03))
{
    audio_pause_sound(mus_dungeon01);
}
else
{
    if (audio_is_paused(mus_dungeon01) &amp;&amp; instance_exists(obj_player)) audio_resume_sound(mus_dungeon01);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!instance_exists(obj_player))
{
    global.wait_frames--;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
